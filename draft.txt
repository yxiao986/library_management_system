整体思路：先搭好项目的框架，然后在AI的帮助下逐一实现。

框架：M-V-C 
M：模型，用于处理数据的逻辑结构
V：用户界面，跟模型无关的东西
C：连接模型和用户界面

首先实现模型层：

1. 定义图书的类别。要处理图书的存储先要定义图书
    对book.py的理解：
    首先定义了图书的具有的基本性质：书名、作者、ISBN索书号、出版社以及出版年份；
    然后定义了一些Special Methods（类别在特定情况下会自动调用的，这些名称不是自定义的）：
    主要是按ISBN进行比较，方便树按照ISBN的大小去排列

2. 然后实现用于处理图书的数据结构，这里要实现三种结构：B树、普通树和平衡树，它们实现的接口名称必须一样，方便在controller函数中随时切换不同的数据结构

    B树 betree.py：
    首先定义B书的叶子：最小度数（最少t-1，最多2t-1，因为这样分裂之后的两个新子键会刚好有t-1个子节点），存储键（book对象）和子节点，以及是否为叶子节点；
    然后实现B树，有四种功能：
        查找：使用递归查找的方式，先遍历每个键，如果找到了就返回，没找到就去相应的子树那里找，没找到且是叶子就返回None；
        插入：先判断加入之后根节点满没满，满了就分裂，再调用没满的插入方法；
        删除：先找到k，
        更新图书信息：先删除旧的，再插入新的
    
    AVL树 avl_tree,py:
        AVL树是一种经典的二叉平衡搜索树，主要通过旋转来保持平衡，私有函数有：获取节点给高度、计算平衡因子、左右旋等；
        查找：BST查找
        插入：BST查找插入后旋转
        删除：BST查找删除后更新高度旋转
        更新：先删除旧的再插入新的


    普通树 bst.py：
        因为普通树没有子节点限制或排列要求，所以直接使用列表去存储所有的子节点；
        正常的普通树的搭建方式应该是类似人为地按类别去分类摆放书籍，但是为了对比实现和其他两种树的四种功能，插入操作的时候限制每个节点最多拥有三个子节点，层序搜索能够插入新节点的节点，使用双端队列
        查找：使用BFS搜索
        插入：层序遍历寻找插入位置
        删除：普通树如果直接删除的话会出现空洞，为了不增添额外的限制，这里的删除使用直接将要删除的节点改为None的方法（跟更新差不多）
        更新：使用BFS搜索到之后更换

3. 然后实现用户界面:定义一个类别，用于定义界面的标题（根据使用的树的类型变化）、按钮等

4. 然后把用户界面的功能和模型的功能连接起来：
    接受界面和树的类别，然后定义按钮所对应的事件发生的函数，然后把按钮和对应的事件联系起来；
    添加图书：接受用户的输入，把图书加入到树中，然后更新列表’
    删除/查找/更新图书：分别根据用户的点击和ISBN查找图书（目前只支持通过ISBN查找图书） #如何通过书名/人名等查找图书？
    四种操作分别对应书的插入、查找、删除和更新
    

5. 然后实现主程序入口 main.py:根据命令行的参数确定树的类型，并创建树

6. 最后进行测试，需要先编写测试数据 generate_books.py, 然后运行benchmark.py获得测试结果
    
    generate_books.py：用随机数编写索书号，用Faker伪造书名等，可以自定义数据的大小，并将生成的.pil文件保存到data文件夹下（.pkl文件是pickle模块将python对象序列化之后的二进制文件）
    benchmark.py：加载图书，分别在随机数据集和有序数据集中测试四种不同的操作所需要的时间，

7. 测试结果：
    运行结果：(数据集大小为5000，没有涉及更新，因为更新所需要的时间本质和查找差不多？)
        
        ===== 随机数据集测试 =====
        测试 BTree on random_books ...
        BTree 插入: 0.0519s, 查找: 0.0450s, 删除: 0.0637s, 查找到: 5000
        测试 OrdinaryTree on random_books ...
        OrdinaryTree 插入: 1.7160s, 查找: 6.5488s, 删除: 0.0044s, 查找到: 5000
        测试 BalancedTree on random_books ...
        BalancedTree 插入: 0.0934s, 查找: 0.0360s, 删除: 0.0857s, 查找到: 5000

        ===== 有序数据集测试 =====
        测试 BTree on ordered_books ...
        BTree 插入: 0.0535s, 查找: 0.0460s, 删除: 0.0612s, 查找到: 5000
        测试 OrdinaryTree on ordered_books ...
        OrdinaryTree 插入: 1.7123s, 查找: 6.5590s, 删除: 0.0045s, 查找到: 5000
        测试 BalancedTree on ordered_books ...
        BalancedTree 插入: 0.1050s, 查找: 0.0356s, 删除: 0.0606s, 查找到: 5000

    时间复杂度分析：
        数据结构	查找 (Search)	插入 (Insert)	删除 (Delete)	更新 (Update)
        层序插入树	O(n)	O(n)	O(n)	O(n)
        AVL树	O(log n)	O(log n)	O(log n)	O(log n)
        B树	O(log n)	O(log n)	O(log n)	O(log n)



